# Деконструкция аббревиатур

Здравствуйте, меня зовут Дмитрий Карловский. А вы на канале "Core Dump", где мы берём разные темы из компьютерной науки и деконструируем их по полочкам.

> **TDD** SRP OCP **LSP** ISP DIP SOLID DRY KISS

Вы можете [читать это как статью](https://github.com/nin-jin/slides/tree/master/abbr), либо [открыть в интерфейсе проведения презентаций](https://nin-jin.github.io/slides/abbr/).

## Деконструкция TDD

Начнём мы с разработки через тестирование. [Видео запись этого раздела](https://youtu.be/sLWURdgEcrI).

> [Test Driven Development](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

Суть этого подхода заключается в ритуализации процесса разработки. То есть в некритическом безусловном выполнении определённых простых действий.

Этот ритуал сделает ваш код красивым и надёжным. Поддерживать его будет легко и просто. А разработка будет простой и быстрой. Так во всяком случае настоятельно убеждают нас проповедники TDD.

### Суть TDD

Вкратце, ритуальный цикл состоит из 3 шагов: сначала пишется красный тест; потом пишется или исправляется код так, чтобы тест позеленел; и наконец код рефакторится, сохраняя зеленоватость тестов.

![Pure TDD](https://habrastorage.org/webt/m7/wm/ts/m7wmts_olawooeqs5kcduncwgyy.png)

И тут сразу возникает вопрос впрос на миллион...

### Что делать, когда тест изначально зелёный?

Варианты ответов...

> ❓ Сломать код
> ❓ Удалить тест
> ❓ Это невозможно

Если сломать код, то тесты естественным образом покраснеют. А после того как мы откатим изменение, тесты снова станут зелёными.

Можно удалить тест. Ведь если нет теста, то нет и проблемы с его изначальным цветом. 

Наконец, моё любимое: по TDD такого быть не должно. Где-то ты накосячил, что у тебя так получилось. Покайся, грешник.

А теперь, внимание, правильный ответ: все эти варианты - это полная беспросветная чушь. Хотя именно один из них, как правило, слышишь от адептов TDD.

### Парадокс воронов

Говоря про ломание кода, нельзя не упомянуть про [парадокс воронов](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81_%D0%B2%D0%BE%D1%80%D0%BE%D0%BD%D0%BE%D0%B2). Суть его в том, что задаётся вопрос: "Все ли вороны чёрные?". И для ответа на него берутся нечёрные предметы. Например - красные яблоки. И каждое такое яблоко как бы подтверждает тезис о том, что "все вороны чёрные", ведь яблоки не чёрные и при этом не вороны. Что-то тут не так с логикой, не правда ли?

![](https://habrastorage.org/webt/bo/fc/-v/bofc-vkmfb4ofo3tzfs3bv5qbdu.png)

Так же как в парадоксе воронов, адепт TDD нередко думает, что падение теста на явно некорректном коде может хоть что-то сказать о том, будет ли тест падать на коде, который похож на корректный. Однако, тут нет никакогой связи. Это просто два разных кода.

Поломка и починка кода - это не более чем бессмысленное действие, необходимое только для того, чтобы форманьно пройти 2 обязательных шага ритуального цикла. Но насколько вероятна эта зелёная ситуация?

### Иначально зелёные тесты неизбежны

Даже для самой простой функции вам не хватит одного теста. Ведь надо рассмотреть позитивные и негативные сценарии, граничные условия, классы эквивалентности. Используя TDD вы сможете написать первый красный тест, другой, третий, но довольно быстро вы столкнётесь с ситуацией, что вы уже написали код, который удовлетворяет всем тест-кейсам, но собственно тестов вы написали ещё меньше половины. И эта ситуация неизбежна.

1. ❌ ⇝ ✅
2. ❌ ⇝ ✅
3. ❌ ⇝ ✅
4. ✅ ❓
5. ✅ ❓
6. ✅ ❓
7. ✅ ❓
8. ✅ ❓

Если мы оставим такие тесты, то это уже будет не TDD, ведь мы написали большую часть тестов уже после кода, а не до. Если же мы их удалим, то код останется попросту недотестированным. И на ближайшем рефакторинге мы скорее всего допустим дефект, который не будет обнаружен ввиду отсутствия теста для соответствующего кейса.

То есть, для обеспечения качества мы вынуждены явно нарушать основную идею TDD: сначала тест, потом код.

### Правильный TDD

Тем не менее, давайте попробуем представить, как мог бы выглядеть TDD здорового человека...

![Fixed TDD](https://habrastorage.org/webt/it/vp/ky/itvpky8gu9nq4_iiyisql-_n6zi.png)

Первым делом мы должны задаться вопросом "А нужен ли нам ещё один тест?". Если мы ещё не покрыли тестами все тест кейсы, значит нужен. И следующим шагом мы пишем тест. Потом проверяем проходит ли он. И если проходит, то возвращаемся на исходную. Если же не проходит, то это значит, что тест и реализация не соответствуют друг другу и нам надлежит это починить. Починка заключается либо в исправлении кода, либо исправлении теста. Проблема может быть и там, и там.

После внесения изменений мы слова прогоняем тесты. И если всё зелёное, то возвращаемся на начало цикла. И вот только когда мы уже покрыли все кейсы тестами и больше тестов нам не надо, только тогда мы начинаем рефакторинг. Если в процессе рефакторинга тесты начнут падать, то нужно будет вернуться к этапу починки.

И, наконец, обратите внимание, что даже после рефакторинга мы задаёмся вопросом "А нужен ли ещё один тест?". Но как же так, - спросите вы, - мы же уже покрыли все тест-кейсы. Причина тут в том, что рефакторинг может приводить к существенному изменению кода. А это в свою очередь может изменить граничные условия, для учёта которых могут потребоваться дополнительные тесты.

В такой форме TDD уже можно применять с пользой. Однако...

### TDD приводит к куче лишней работы

TDD предлагает нам даже не пытаться писать полнофункциональную реализацию, ограничившись лишь минимальной реализацией достаточной для прохождения очередного теста. Следовательно мы зачастую будем писать явно некорректный код, который на следующий итерации будет отправляться в мусорную корзину.

Давайте рассмотрим типичный сценарий написания простой функции...

| Итерация | В начале        | В процесссе     | В результате
|----------|-----------------|-----------------|--------------------------
| 1        | ❌             | ❌              | ✅
| 2        | ✅❌           | ❌❌           | ✅✅
| 3        | ✅✅❌        | ❌❌❌         | ✅✅✅
| 4        | ✅✅✅❌      | ✅✅❌❌      | ✅✅✅✅
| 5        | ✅✅✅✅❌   | ✅✅✅✅❌    | ✅✅✅✅✅
| 6        | ✅✅✅✅✅❌ | ❌❌❌❌❌❌ | ✅✅✅✅✅✅

Первые несколько итераций мы выкидываем ранее написанный код полностью. Это приводит к покраснению воообще всех тестов, после чего нам приходится уже писать код так, чтобы он проходил сразу несколько тестов. То есть мы приходим к ситуации, как если бы мы сразу написали несколько тестов, и только после этого взялись писать код. А все предыдущие итерации получается не имели никакого смысла.

Но всё не так плохо, с какого-то момента мы перестанем выбрасывать код полностью, и добавление нового теста уже не будет приводить нас к существенному переписыанию кода. То есть цикл TDD наконец-то начнёт работать как задумывался.

Однако, всё ещё остаётся довольно высокая вероятность в любой момент столкнуться с такой ситуацией, что очередное изменение кода сломает вообще все тесты. Ну или как минимум большую их часть. А значит мы снова возвращаемся к ситуации "все тесты уже написаны, нужно лишь написать правильно код". А все те осторожные шажки по одному тесту, что мы делали ранее, просто обесцениваются.

### Когда TDD полезен

Как было отмечено ранее применение TDD в общем случае скорее вредно, чем полезно. Но в некоторых случаях оно может быть оправдано..

> ✅ Исправление дефектов
> ✅ Заранее известный контракт
> ✅ Не заставить себя писать тесты

Если к вам пришёл баг, то вы его можете сперва формализовать в виде теста, а далее исправлять код, пока все тесты не позеленеют.

Кроме того, в ситуации, когда контракт вам известен заранее, вы можете сразу написать все тесты, а потом уже весь код, который им соответствует. Формально, это будет не TDD, так как вы не будете менять код после добавления каждого теста. Однако, это самый что ни на есть Test Driven, так как тесты будут диктовать вам реализацию.

Наконец, TDD может помочь вам с самодисциплиной и заставить-таки писать тесты. Но если у вас проблема с самодисциплиной, то возможно и заставить применять TDD вам будет не очень просто. Но тут вера может творить чудеса.

### Программировать ли по TDD?

Если кто-то вам скажет, что он "программирует по TDD", то можете быть уверены, что он попросту не ведает, что творит. У TDD есть ряд фундаментальных проблем, поэтому его применение оправдано лишь в весьма ограниченном числе случаев. И то, не в той форме в которой ему как правило учат многочисленные коучи.

> ❌ Ритуализация
> ❌ Явно некорректный код
> ❌ Бесполезная работа
> ✅ Там, где это уместно
> ✅ Не зацикливаться

Пропагантируя TDD, евангелисты часто сравнивают разработку по TDD с разработкой без тестов вообще. Что, конечно же, не корректно. Автоматические тесты писать безусловно нужно, если вы конечно хотите обеспечить хороший уровень качества, так как ручное тестирование из-за человеческого фактора неизбежно пропускает дефекты. Но нельзя отождествлять автоматические тесты и TDD. Последний - это вполне конкретный ритуал по написанию автоматических тестов. Но автоматические тесты можно писать и без какой-либо ритуализации. Просто включаем голову и пишем их так, как нужно, тогда, когда нужно.

### Что ещё посмотреть по TDD?

Если вам не хватило этого разбора, то можете ознакомиться со следующими выступлениями, раскрывающими вопрос с иных сторон..

- [Егор Бугаенко — TDD вверх ногами](https://www.youtube.com/watch?v=3QT7jaoOa9w)
- [TDD: когда нужно и, самое главное, когда не нужно / Павел Калашников](https://www.youtube.com/watch?v=QT1yDL-L0t4)
- [Dependency Rejection and TDD without Mocks. Антон Молдован](https://www.youtube.com/watch?v=9zpG_hJsrL8)

## Деконструкция LSP

> [Liskov Substitution Principle](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%BF%D0%BE%D0%B4%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8_%D0%91%D0%B0%D1%80%D0%B1%D0%B0%D1%80%D1%8B_%D0%9B%D0%B8%D1%81%D0%BA%D0%BE%D0%B2)

Принцип подстановки был сформулирован Барбарой Лисков 1987 году.

### Сужение типа

Подтип - частный случай надтипа.

![](https://habrastorage.org/webt/hs/7p/hl/hs7phlymhzqtlozr3c89xqflcr8.png)

### Произведние типов

Произведение является подтипом нескольких ортогональных типов.

![](https://habrastorage.org/webt/av/lp/pd/avlppdmufjxnr7swrtvsooampow.png)

### Параметрический полиморфизм

Возможность функции работать с параметрами разных типов.

![](https://habrastorage.org/webt/pa/h_/ql/pah_qlc7fgcdxwzuyvt9poboary.png)

### Суть LSP - повсеместная ковариантность

Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

![](https://habrastorage.org/webt/ox/dv/w4/oxdvw4pnkf7opg-88jxjwstk40u.png)

LSP на самом деле про ковариантность всех параметров всех функций.

### Контравариантность не вписывается в LSP

Это инверсия LSP. Возможность подстановки зависит не от типа параметра, а от того, что функция с ним делает.

![](https://habrastorage.org/webt/vr/lh/_v/vrlh_vkmoksuxrfqb6cynzji7pq.png)

Есть также бивариантность и инвариантность.

### Виды вариантностей

1. Только чтение - ковариантность (LSP)
2. Только запись - контравариантность
3. Чтение и запись - инвариантность/бивариантность

### Применимость LSP

LSP - устаревшая концепция, не учитывающая многие случаи. Теория вариантности - более общая и логически обоснованная.

> ✅ Функциональное программирование

### Следовать ли LSP?

> ❌ No

### Что ещё почитать о вариантности?

- [Теория программирования: Вариантность](https://github.com/nin-jin/HabHub/issues/22)

## Деконструкция SOLID

```
❌ SRP
❌ OCP
❌ LSP
❌ ISP
❌ DIP
```

### Что ещё почитать по SOLID?

- [Когда НЕ нужно использовать SOLID?](https://ru.stackoverflow.com/questions/551346/%D0%9A%D0%BE%D0%B3%D0%B4%D0%B0-%D0%9D%D0%95-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-solid)

# Продолжение следует..

> ✅ Лайк
> ✅ Подписка
> ✅ Комментарий
> ✅ Поделись-ка

Если данный разбор показался вам полезным, то дайте мне об этом знать посредством лайка. А так же поделитесь ссылкой на него со своими коллегами. Особенно с теми, кто действительно практирует TDD.

Если же вы не согласны с какой-либо мыслью или, наоборот, чувствуете какую-то недосказанность и хотите дополнить своими идеями, то жду ваших коментариев.

Наконец, подписывайтесь на канал, чтобы не пропустить дальнейшие разборы. Нам ещё много чего с вами нужно будет обсудить.

На этом пока что всё. С вами был боевой программер Дмитрий Карловский. 
