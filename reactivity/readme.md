# Разбираемся в сортах реактивности

Сравним различные подходы к реактивному программированию. Вытащим на поверхность их подводные камни. И разберём как реактивность решает или наоборот усугубляет проблемы.

![](reactivity-reactivity.svg)

Это - текстовая расшифровка выступления на [SECON.Weekend Frontend](https://secon.ru/projects/seconweekend). Вы можете [прочитать как статью](https://github.com/nin-jin/slides/tree/master/reactivity), либо [открыть в интерфейсе проведения презентаций](https://nin-jin.github.io/slides/reactivity/).

# Человек-реактив

- 🎶 15 лет во фронтенде
- 🧪 6 лет с реактивами
- 😭 Пилил на Angular, RXJS и MobX
- ✨ Свои либы с уникальными фичами
- 💞 Целый фреймворк на их основе

# Огнеопасно!

Я постараюсь быть максимально объективен, но.. Возможны помочные эффекты..

- 💥 Жжение в нижних отделах спины
- 👐 Зуд на кончиках пальцев
- 📢 Повышение громкости речевого аппарата
- 🧠 Усиленная напряжённость в области извилин

# Виды активностей

- 🌠Интерактивность
- 🚀Реактивность

## 🌠Интерактивность

Система выполнила только то, что просили.. И ждёт дальнейших команд.

![](reactivity-interactive.svg)

## 🚀Реактивность

Система выполнила то, что просили.. Плюс сама обновила всё приложение.

![](reactivity-reactive.svg)

# Что нужно для реактивности?

- 📦Состояния
- 🎬Акции
- 💨Реакции
- 💫Инварианты
- 🌉Каскад
- 🧙‍♂️Рантайм

## 📦Состояния

![](reactivity-states.svg)

## 🎬Акции

![](reactivity-actions.svg)

## 💨Реакции

![](reactivity-reactions.svg)

## 💫Инварианты

![](reactivity-invariants.svg)

Далее речь будет идти преимущественно про этот тип реакций. Но порой будем упоминать и сайд эффекты.

## 🌉Каскад

![](reactivity-cascade.svg)

## 🧙‍♂️Рантайм

![](reactivity-runtime.svg)

# Общие пожелания к реактивности

- 🤹‍♂️ Отсутствие ненужных вычислений
- 🐵 Стабильность поведения
- 🐘 Минимальное потребление памяти
- 💫 Согласованность состояний

## 🤹‍♂️ Отсутствие ненужных вычислений

Лишние вычисления растут как снежный ком. Чем раньше их остановим, тем меньше ресурсов суммарно потратим.

![](reactivity-snowboll.svg)

## 🐵 Стабильность поведения

После изменения состояния результат должен быть такой же, как старт с нуля в этом же состоянии. Иначе реальное поведение может отличаться от того, на котором отлаживаешь.

![](reactivity-stable.svg)

## 🐘 Минимальное потребление памяти

В V8, в самом оптимистичном случае, когда JIT максимально заоптимизировал..

| Value    | Place   | Cost
|----------|---------|-----
| Obj      | Heap    | 12
| Array    | Heap    | 24
| Unit     | Inplace | 4
| Int      | Inplace | 4
| Float    | Heap    | 12
| BigInt   | Heap    | 16+
| String   | Heap    | 12+
| Ref      | Inplace | 4
| Closure  | Heap    | 24
| Context  | Heap    | 16

То, что лежит в Heap кушает дополнительные 4 байта на ссылку (Ref). Unit - это всякие undefined, null, false, true и прочие малые невариативные примитивные значения. Int после миллиарда хранится уже как Float, мантисса которого - 48 бит. Обратите внимание, что это уже ссылочный тип, как и BigInt. Контекс для замыкания хранится, только если функция замкнута на какие-либо переменные. Размер контекста, соответственно, зависит от числа этих пееменных. Как видно, каждая переменная добавляет к контексту по 4 байта.

Небольшой пример расчёта потребелния памяти...

```
function make_ints_state( ... state: number[] ) {
	return { get: ()=> state }
}

const state1 = make_ints_state( 777 )
// Ref + Obj + Ref + Closure + Ref + Context + Ref + Array + Int
// 4   + 12  + 4   + 24      + 4   + 16      + 4   + 24    + 4   = 96


const state2 = { state: 777 }
// Ref + Obj + Int
// 4   + 12  + 4   = 20


const state3 = 777
// Int
// 4
```

Накладные расходы могут отливаться на порядок.

## 💫 Согласованность состояний

В лучшем случае при несогласованности пользователь будет обескуражен. В худшем - и вы, и он потеряете деньги, репутацию и тд.

![](reactivity-interactive.svg)

# Аспекты реактивности

- **Style**: Стилистика кода
- **Origin**: Кто инициатор изменения состояния?
- **Watch**: Наблюдение за изменениями
- **Dupes**: Игнор эквивалентных изменений
- **Tonus**: Энергичность реакций 
- **Order**: Порядок реакций 
- **Flow**: Конфигурация потоков данных  
- **Error**: Поведение в исключительных ситуациях 
- **Cycle**: Циклические зависимости 
- **Atomic**: Атомарность изменений
- **Depth**: Ограничение глубины 
- **Extern**: Внешние взаимодействия

## Style: Стилистика кода

- 🧐Proc: Процедурный
- 🤓Obj: Объектный
- 🤯Func: Функциональный

### 🧐Proc: Процедурный стиль

Эпизодически запускается процедура обновления, которая что-то читает, что-то пишет. Простейшая рализация..

```javascript
let Name = 'Jin'
let Count
let Short

setInterval( ()=> {
	Count = Name.length
} )

setInterval( ()=> {
	Short = Count < 4
} )
```

### 🤓Obj: Объектный стиль

Программа состоит из множества объектов, обладающих состояниями, связанных инвариантами в единый граф. Типичная реализация..

```javascript
class State {
	
	@mem Name( next = 'Jin' ) {
		return next
	}
	
	@mem Count() {
		return this.Name().length
	}
	
	@mem Short() {
		return this.Count() < 4
	}
	
}
```

### 🤯Func: Функциональный стиль

Инварианты описываются в виде чистых функций. Каноничная реализация..

```javascript
const Name = new BehaviorSubject( 'Jin' )

const Count = Name.pipe(
	map( Name => Name.length )
)

const Short = Count.pipe(
	map( Count => Count < 4 )
)
```

## Origin: Кто инициатор изменения состояния?

- 🥌Push: Зависимость проталкивает
- 🚂Pull: Зависимый затягивает

### 🥌Push: Зависимость проталкивает

При изменении зависимости срабатывают реакции, которые пишут в зависимые состояния новые значения.

![](reactivity-push.svg)

### 🚂Pull: Зависимый затягивает

При обращении зависимому состоянию срабатываются реакции, которые вытягивают из зависимостей актуальные значения.

![](reactivity-pull.svg)

## Watch: Наблюдение за изменениями

- 🔎Polling: Периодическая сверка
- 🎇Events: Возникновение события
- 🤝Links: Список подписчиков

### 🔎Polling: Периодическая сверка

Состяния хранят лишь значения и всё. Рантайм периодически сверяет текущее значение с предыдущим. И если они отличаются - пушит в зависимые состояния новые значения. Так работает Angular.

```javascript
// sometimes
if( state !== state_prev ) reactions()
```

### 🎇Events: Возбуждение события

Каждое состояние хранит список функций обработчиков изменения. Больше ничего оно про другие состояния не знает.

```javascript
// on change
for( const reaction of this.reactions ) {
	reaction()
}
```

### 🤝Links: Список подписчиков

Состояния хранят прямые ссылки друг на друга, образуя глобальный граф.

```javascript
// on change
for( const slave of this.slaves ) {
	slave.obsolete()
}

// on complete
for( const master of this.masters ) {
	master.finalize()
}
```

## Dupes: Игнор эквивалентных изменений

Когда значение обновляется на эквивалентное.

- 👯‍♀️Every: Реакция на каждое действие
- 🆔Identity: Сравнение по ссылке
- 🎭Equality: Структурное сравнение

### 👯‍♀️Every: Реакция на каждое действие

Даже если состояние фактически не меняется, реакции всё-равно отрабатывают.

```ts
777 != 777
```

### 🆔Identity: Сравнение по ссылке

Если состояние не поменялось, то реакции не срабатывают. А если поменялось, даже на эквивалентное значение, то срабатывают.

```ts
        777 == 777

[ 1, 2, 3 ] != [ 1, 2, 3 ]
```

### 🎭Equality: Структурное сравнение

Реакции срабатывают только если состояние поменялось на неэквивалентное значение.

```ts
        777 == 777

[ 1, 2, 3 ] == [ 1, 2, 3 ]

[ 1, 2, 3 ] != [ 3, 2, 1 ]
```

## Tonus: Энергичность реакций

- 🍔Instant: Мгновенные
- ⏰Defer: Отложенные
- 🦥Lazy: Ленивые

### 🍔Instant: Мгновенные реакции

Пересчёт зависимых состояний происходит сразу же при изменении зависимости. Приводит к лишним вычислениям и временной неконсистентности.

![](reactivity-instant.svg)

### ⏰Defer: Отложенные реакции

Пересчёт зависимых состояний откладывается на потом, но происходит в любом случае.

![](reactivity-defer.svg)

### 🦥Lazy: Ленивые реакции

Пересчёт зависимого состояния происходит лишь в момент обращения к нему.

![](reactivity-lazy.svg)

## Order: Порядок реакций

- 📰Subscribe: По времени подписки
- 🧨Event: По времени возникновения события
- 📶Deep: По глубине зависимости
- 👨‍💻Code: По положению в программе

### 📰Subscribe: Реагирование по времени подписки

Какая реакция появилась раньше, та и срабатывает раньше. Получается скрытое состояние, влияющее на работу приложения через разный порядок срабатывания сайд-эффектов.

![](reactivity-order-subscribe.svg)

### 🧨Event: Реагирование по времени возникновения события

Чем раньше изменилось состояние, тем раньше сработают реакции на его изменение.

![](reactivity-order-event.svg)

### 📶Deep: По глубине зависимости

![](reactivity-order-deep.svg)

### 👨‍💻Code: Реагирование по положению в программе

Чем раньше в заданном кодом потоке исполнения находится реакция, тем раньше она сработает.

![](reactivity-order-code.svg)

## Error: Поведение в исключительных ситуациях

- 🎲Unstable: Нестабильная работа
- ⛔Stop: Прекращение работы
- 🦺Store: Индикация ошибки и ожидание восстановления
- ⏮Revert: Откат к стабильному состоянию

### 🎲Unstable: Нестабильная работа при ошибке

Обычно следствие неконсистентного состояния.

![](reactivity-error-unstable.svg)

### ⛔Stop: Прекращение работы при ошибке

Требуется перезапуск всего приложения или отдельной его части.

![](reactivity-error-stop.svg)

### 🦺Store: Индикация ошибки и ожидание восстановления

Приложение частично помечается невалидным. Устранение причины исключительной ситуации восстанавливает нормальную работу.

![](reactivity-error-store.svg)

### ⏮Revert: Откат к стабильному состоянию при ошибке

Возможна ситуация, когда из-за ошибки в далёкой реакции невозможно изменить первичное состояние.

![](reactivity-error-revert.svg)

## Flow: Конфигурация потоков данных

- 🦽Manual: Ручная
- 🚕Auto: Автоматическа

### 🦽Manual: Ручная конфигурация потоков данных

Движение информации по состояниям задаётся в коде и без явного указания не меняется в процессе работы программы. Забыли подписаться - неконсистентность. Забыли отписаться - лишние вычисления.

![](reactivity-manual.svg)

### 🚕Auto: Автоматическая конфигуация потоков данных

Движение информации происходит наиболее оптимальным образом для текущего состояния. При изменений состояния, информационные потоки перестраиваются автоматически.

![](reactivity-auto.svg)

## Cycle: Циклические зависимости

- 💤Infinite: Бесконечный цикл
- 🔮Limbo: Произвольный результат
- ⛔Fail: Приводят к ошибке
- 🚫Unreal: Невозможны

### 💤Infinite: Бесконечный цикл

Позволяют просто решать некоторые задачи. Но при неосторожном обращении могут зависнуть.

![](reactivity-cycle-allow.svg)

### 🔮Limbo: Произвольный результат

При косвенном обращении к тому же стейту, который вычисляется, используется предыдущее значение. В зависимости от порядка вычислений даёт разные результаты.

![](reactivity-cycle-limbo.svg)

### ⛔Fail: Приводят к ошибке

Детектируются в рантайме и кидают исключение. При тестировании могут быть не выявлены, а выстрелить у пользователя.

![](reactivity-cycle-fail.svg)

### 🚫Unreal: Невозможны

Синтаксически невозможно создать. Вроде хорошо, но накладывает сильные ограничения на прикладные возможности.

![](reactivity-cycle-unreal.svg)

## Extern: Внешние взаимодействия

Порой инвариант требует асинхронной коммуникации. Например, при тяжёлых рассчётах в отдельном воркере.

- 🏊‍♂️Sync: Синхронные инварианты
- 🏇Async: (А)синхронные инварианты

### 🏊‍♂️Sync: Поддерживаются только синхронные инварианты

Согласованность состояний на время сайд-эффекта лежит на плечах прикладника. Как правило это хрупкий интерактивный код.

```ts
const image = source_element.pipe( map( capture ) )
const data = image.pipe( map( recognize ) )
const text = data.pipe( map( data => data.text ) )

text.subscribe( text => {
	output.innerText = text
} )
```

### 🏇Async: Поддерживаются асинхронные инварианты

Согласованность состояний сохраняется автоматически.

```ts
text*() {
	const image = yield capture( this.source_element )
	const data = yield recognize( image )
	return data.text
}
```

## Depth: Ограничение глубины

- 🗻Stack: Ограничена стеком
- 🌌Heap: Не ограничена

### 🗻Stack: Ограничена стеком

На глубоких зависимостях (1-2к) реактивность может ломаться. Эксель на таком не построишь.

```ts
first() {
	this.second()
}

second() {
	this.third()
}

thisrd() {
	this.etc()
}
```

### 🌌Heap: Не ограничена

Глубина зависимостей может быть произвольной, на сколько хватит оперативки.

```ts
while( reactions.length ) {
	const reaction = reactions.shift()
	reaction()
}
```

## Atomic: Атомарность изменений

- 👻Alone: Одного отдельного состояния
- 🦶Base: Для первичных состояний
- 🤼‍♂️Full: Для всех состояний

### 👻Alone: Атомарность изменения лишь одного состояния

Можно начать изменение, но не закончить из-за ошибки, и получится несогласованное состояние.

```ts
Name = 'John'
Count = 4

Name = 'Jin'
throw 'function is not a function'
Count = 3 // still 4
```

### 🦶Base: Атомарность изменения первичных состояний

Первичные состояния всегда обновляются атомарно, а вторичные лишь следуют за текущим состоянием первичных.

```ts
Name = 'John'
Count = 4

@transaction update() {
	this.Name = 'Jin' // will still 'John'
	throw 'function is not a function'
	this.Count = 3
}
```

### 🤼‍♂️Full: Атомарность изменения всех состояний

При возникновении ошибки при обновлении вторичных состояний откатываются и первичные.

```ts
Name = 'John'
Count = 4

@derived get Greeting() {
	// Fails on 'Jin' name
	return this.Name.split('')[3].toUppercase()
}

@transaction update() {
	this.Name = 'Jin' // will still 'John'
	this.Count = 3 // will still 4
}
```

# Оценка практичности

Сформулируем видение идеальной системы реактивности в вакууме..

| Aspect  | ✅Usable   | ❌Unusable
|---------|------------|---------
| Style   | 🤓Obj      | 🧐Proc 🤯Func
| Origin  | 🚂Pull     | 🥌Push
| Watch   | 🤝Links    | 🔎Polling 🎇Events
| Dupes   | 🎭Equality | 🆔Identity 👯‍♀️Every
| Order   | 👨‍💻Code     | 📰Subscribe 🧨Event 📶Deep
| Flow    | 🚕Auto     | 🦽Manual 

| Aspect  | ✅Usable   | ❌Unusable
|---------|-------------|---------
| Tonus   | 🦥Lazy     | 🍔Instant ⏰Defer
| Error   | 🦺Store    | ⛔Stop ⏮Revert 🎲Unstable
| Cycle   | ⛔Fail     | 💤Infinite 🔮Limbo 🚫Unreal
| Atomic  | 🦶Base     | 🤼‍♂️Full 👻Alone
| Depth   | 🌌Heap     | 🗻Stack
| Extern  | 🏇Async    | 🏊‍♂️Sync

# Поведение по умолчанию

Далее рассматриваем лишь поведение по умолчанию и рекомендуемый автором стиль кода. Понятное дело, что всегда можно как-то обойти его, только надо не забыть написать дополнительный код, однако..

- 🎓 Выбор эксперта
- 🐭 Минимум кода
- 👀 Повышенное внимание
- 👾 Сторонний код

# Реактивные библиотеки

Везде рассматривается поведение по умолчанию, если человек не написал дополнительного кода для изменения поведения. 

| Lib         | Style | Origin | Watch | Dupes | Tonus | Order | Error | Flow  | Cycle | Extern | Depth | Atomic
|-------------|-------|--------|-------|-------|-------|-------|-------|-------|-------|--------|-------|-------
| CellX       | 🤓✅ | 🚂✅  | 🤝✅ | 🆔❌ | 🦥✅ | 👨‍💻✅ | 🦺✅ | 🚕✅ | ⛔✅ | 🏇✅  | 🗻❌ | 🦶✅
| $mol_atom2  | 🤓✅ | 🚂✅  | 🤝✅ | 🎭✅ | 🦥✅ | 👨‍💻✅ | 🦺✅ | 🚕✅ | ⛔✅ | 🏇✅  | 🗻❌ | 👻❌
| MobX        | 🤓✅ | 🚂✅  | 🤝✅ | 🆔❌ | 🦥✅ | 👨‍💻✅ | 🦺✅ | 🚕✅ | ⛔✅ | 🏊‍♂️❌  | 🗻❌ | 👻❌
| ChronoGraph | 🧐❌ | 🚂✅  | 🤝✅ | 🆔❌ | ⏰❌ | 👨‍💻✅ | ⏮❌ | 🚕✅ | ⛔✅ | 🏊‍♂️❌  | 🌌✅ | 🤼‍♂️❌
| Reatom      | 🤯❌ | 🚂✅  | 🤝✅ | 🆔❌ | 🦥✅ | 🧨❌ | ⏮❌ | 🦽❌ | 🚫❌ | 🏊‍♂️❌  | 🗻❌ | 🤼‍♂️❌
| Effector    | 🤯❌ | 🥌❌  | 🤝✅ | 🆔❌ | 🍔❌ | 📰❌ | 🎲❌ | 🦽❌ | 💤❌ | 🏊‍♂️❌  | 🗻❌ | 👻❌
| RxJS        | 🤯❌ | 🥌❌  | 🤝✅ | 👯‍♀️❌ | 🍔❌ | 📰❌ | ⛔❌ | 🦽❌ | 🚫❌ | 🏊‍♂️❌  | 🗻❌ | 👻❌

Видно два основных лагеря: Объектное Реактивное Программирование и Функциональное Реактивное Программирование. Пока я готовил этот материал побеждал, как обычно, $mol. Но за пару дней CellX вырвался таки вперёд. Ну да не страшно, я всё-равно пока не рекомендую завязываться на $mol_atom, ибо готовлю новую реализацию основанную на [Auto Wire JS Proposal](https://gist.github.com/nin-jin/6b9765fb9d0d50c2e1d37689008f5357), который позволяет разным реактивным библиотекам взаимодействовать друг с другом и с нативным браузерным API через единые интерфейсы.

# Реактивные фреймворки

| Lib     | Style | Origin | Watch | Dupes | Tonus | Order | Error | Flow  | Cycle | Extern | Depth | Atomic
|---------|-------|--------|-------|-------|-------|-------|-------|-------|-------|--------|-------|-------
| Vue     | 🤓✅ | 🚂✅  | 🤝✅ | 🆔❌ | 🦥✅ | 👨‍💻✅ | 🦺✅ | 🚕✅ | 🔮❌ | 🏇✅  | 🗻❌ | 👻❌
| React   | 🧐✅ | 🥌❌  | 🔎❌ | 🆔❌ | ⏰❌ | 👨‍💻✅ | ⛔❌ | 🦽❌ | ⛔✅ | 🏇✅  | 🗻❌ | 👻❌
| Angular | 🧐✅ | 🥌❌  | 🔎❌ | 🆔❌ | ⏰❌ | 👨‍💻✅ | 🎲❌ | 🚕✅ | 🔮❌ | 🏊‍♂️❌  | 🗻❌  | 👻❌
| Svelte  | 🧐✅ | 🥌❌  | 🔎❌ | 🆔❌ | ⏰❌ | 👨‍💻✅ | ⛔❌ | 🚕✅ | 🚫❌ | 🏊‍♂️❌  | 🌌✅  | 👻❌

Не стоит слепо доверять этой табличке, ибо составлена она вручную. Я, конечно, старался точно всё отразить, но мог и накосячить. Поэтому..

# Что ещё глянуть по теме

Проект по классификации стейт-менеджеров с помощью тестов от Артёма - автора reatom. Иной обстоятельный взгляд на вопрос реактивности от Криса. И пара моих выступлений разбирающих преимущества ОРП и механику реализации асинхронных инвариантов.

- [state-management-specification](https://github.com/artalar/state-management-specification) / Артём Арутюнян
- [A General Theory of Reactivity](https://github.com/kriskowal/gtor) / Kris Kowal
- [Объектное Реактивное Программирование](https://github.com/nin-jin/slides/tree/master/orp) @ FrontendConf'17
- [Квантовая механика вычисления на JS](https://github.com/nin-jin/slides/tree/master/fibers) @ HolyJS'18

# Что ещё глянуть не по теме

- [slides.hyoo.ru](https://slides.hyoo.ru/) - выступления
- [Core Dump](https://www.youtube.com/channel/UC-qEImMrqSLZ9KLee1JTcuw) - фундамент
- [habhub.hyoo.ru](https://habhub.hyoo.ru/) - статьи
- [`_jin_nin_`](https://twitter.com/_jin_nin_) - новости

# Пишите письма!

![](https://habrastorage.org/webt/um/jg/hz/umjghz4nc3jqzxx5morka4jm-58.jpeg)
