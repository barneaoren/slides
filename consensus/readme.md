# Консистентно о Консенсусе

Здравствуйте, меня зовут Дмитрий Карловский. А вы на канале [Core Dump](https://www.youtube.com/channel/UC-qEImMrqSLZ9KLee1JTcuw), где мы берём разные темы из компьютерной науки и раскладываем их по полочкам.

И на этот раз мы постараемся прийти к согласию касательно согласованной классификации алгоритмов обеспечения консенсуса в системах со множеством участников. И попробуем выявить их фундаментальные особенности, проявляющиеся на разных масштабах: от ядер процессора, до серверных кластеров.

![](short.svg)

Вы можете [читать это как статью](https://github.com/nin-jin/slides/tree/master/consensus), либо [открыть в интерфейсе проведения презентаций](https://nin-jin.github.io/slides/consensus/).

## Согласованность данных

Начнём с консистентности. Она же согласованность. Это - логическая непротиворечивость хранимых данных.

Например, если у Алисы родителем значится Боб, а у Боба родителем значится Алиса, то это явно какая-то лажа. Не могут они быть родителями друг друга одновременно. Данные не консистентны!

![](inconsistency.svg)

Согласованность часто путают с консенсусом. Особенно, когда данные частично хранятся на одном сервере, а частично на другом, но при этом должны быть друг с другом согласованы. Однако, консенсус немного о другом..

## Согласие между участниками

Консенсус - это согласие группы участников касательно значения некоторого состояния. Например, если все считают Боба мужчиной, но сам он считает себя вертолётом, то согласия тут не наблюдается. Консенсус не достигнут!

![](discord.svg)

Важно понимать, что даже если у каждого участника состояние консистентно, между участницами при этом консенсуса может и не быть. И наоборот, участники могут достигнуть консенсуса, но получить при этом неконсистентное состояние.

## Достижение консенсуса

Все подходы по достижению консенсуса можно разделить на две большие группы..

![](consensus.svg)

Первая - это конкуренция за единый источник истины. Участники толпятся вокруг него, толкаются локтями, и пытаются внести в него свои изменения. Транзакции в базах данных, атомарные операции в многопоточке, протоколы консенсуса в распределённых системах - это всё из этой оперы.

Совершенно иной подход - конвергенция. Она же сходимость. Это кода участники независимо друг от друга меняют каждый своё состояние. И только своё. Но при этом они могут подглядывать к соседям и подливать их изменения к себе. А алгоритмы слияния изменений строятся так, чтобы состояния всех участников в конечном счёте сошлись к одному и тому же значению.

## Конкуренция за источник истины

Разберём подробнее конкуренцию за источник истины. Это может быть мастер-реклика в распределённой СУБД, основной поток приложения или просто общий участок памяти.

Читать из источника могут все участники одновременно. Но при попытке записать участник может быть заблокирован, пропуская вперёд более удачливых участников. 

Тут можно выделить два вида блокировок: пессимистичная и оптимистичная.

![](concurrency.svg)

## Пессимистичная блокировка

Идея пессимистичной блокировки простая: сначала участник запирает ресурс, затем производит его обновление, по завершении которого ресурс освобождается. Это если ему повезло прийти первым. Если же он пришёл, а ресурс уже кем-то заблокирован, то он сидит, ничего не делает, и ждёт освобождения.

![](pessimistic.svg)

Это самый простой и надёжный подход. Однако у него есть проблемы с производительностью. Либо из-за постоянных ожиданий, либо из-за холостых захватов.

Кроме того, этот подход подвержен проблеме взаимной блокировки, когда два участника успешно захватывают два разных ресурса, а потом блокируются при попытке захватить ресурс уже захваченный оппонентом.

## Оптимистичная блокировка

Если конкуренция не слишком высока, оптимистичная блокировка может показать себя гораздо лучше.

![](optimistic.svg)

## Толерантность к разделению

Отличительной особенностью источника истины является возможность гарантировать консистентность.

Но согласие невозможно при разделении сети. Не можешь победить? Возглавь!

## Сходимость к согласию

Скорее всего вы слышали термин "Eventual Cоnsistency" или "Согласованность в конечном счёте". Так вот, оно на самом деле не про консистентность, а именно про конвергенцию. Wait-free алгоритмы межпоточного взаимодействия основаны на той же идее - отсутствие конкуренции за общий ресурс.

Однако, важно понимать, что консистентность тут уже в общем случае не может быть гарантирована. Так как слияние консистентных по отдельности изменений может выдавать уже неконсистентное состояние. Но с этим можно жить, если правильно организовывать данные и уметь нормализовывать неконсистентное состояние.

![](convergence.svg)

## Упорядоченная конвергенция

> OT: Operational Transformation

![](order.svg)

## Полу-упорядоченная конвергенция

> CmRDT: Conflict-free Commutative Replicated Data Type

![](semi-order.svg)

## Беспорядочная конвергенция

> CvRDT: Conflict-free Convergent Replicated Data Type

![](unorder.svg)

## Согласны?

![](full.svg)

## Продолжение следует..

> ✅ Лайк
> ✅ Подписка
> ✅ Комментарий
> ✅ Поделись-ка

А на этом пока что всё. С вами был.. беспорядочный программер Дмитрий Карловский.