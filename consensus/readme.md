# Консистентно о Консенсусе

Здравствуйте, меня зовут Дмитрий Карловский. А вы на канале [Core Dump](https://www.youtube.com/channel/UC-qEImMrqSLZ9KLee1JTcuw), где мы берём разные темы из компьютерной науки и раскладываем их по полочкам.

И на этот раз мы постараемся прийти к согласию касательно согласованной классификации алгоритмов обеспечения консенсуса в системах со множеством участников. И попробуем выявить их фундаментальные особенности, проявляющиеся на разных масштабах: от ядер процессора, до серверных кластеров.

![](short.svg)

Вы можете [читать это как статью](https://github.com/nin-jin/slides/tree/master/consensus), либо [открыть в интерфейсе проведения презентаций](https://nin-jin.github.io/slides/consensus/).

## Согласованность данных

Начнём с консистентности. Она же согласованность. Это - логическая непротиворечивость хранимых данных.

Например, если у Алисы родителем значится Боб, а у Боба родителем значится Алиса, то это явно какая-то лажа. Не могут они быть родителями друг друга одновременно. Данные не консистентны!

![](inconsistency.svg)

Согласованность часто путают с консенсусом. Особенно, когда данные частично хранятся на одном сервере, а частично на другом, но при этом должны быть согласованы друг с другом. Однако, консенсус немного о другом..

## Согласие между участниками

Консенсус - это согласие группы участников касательно значения некоторого состояния. Например, если все считают Боба мужчиной, но сам он считает себя вертолётом, то согласия тут не наблюдается. Консенсус не достигнут!

![](discord.svg)

Важно понимать, что даже если у каждого участника состояние само по себе консистентно, между участниками консенсуса при этом может и не быть. И наоборот, участники могут достигнуть согласия касательно состояния, но получить при этом несогласованные данные.

## Достижение согласия

Все подходы по достижению консенсуса можно разделить на две большие группы..

![](consensus.svg)

Первая - это конкуренция за единый источник истины. Участники толпятся вокруг него, толкаются локтями, и пытаются внести в него свои изменения. Транзакции в базах данных, атомарные операции в многопоточке, протоколы консенсуса в распределённых системах - это всё из этой оперы.

Совершенно иной подход - конвергенция. Она же сходимость. Это кода участники независимо друг от друга меняют каждый своё и только своё состояние. Но при этом они могут подглядывать к соседям и подливать их изменения к себе. А алгоритмы слияния изменений строятся так, чтобы состояния всех участников в конечном счёте сошлись к одному и тому же значению.

## Конкуренция за источник истины

Разберём подробнее конкуренцию за источник истины. Это может быть мастер-реклика в распределённой СУБД, основной поток приложения или просто общий участок памяти.

Читать из источника могут все участники одновременно. Но при попытке записать участник может быть заблокирован, пропуская вперёд более удачливых участников. 

Тут можно выделить два вида блокировок: пессимистичная и оптимистичная.

![](concurrency.svg)

## Пессимистичная блокировка

Идея пессимистичной блокировки простая: сначала участник запирает ресурс, затем производит его обновление, по завершении которого ресурс освобождается. Это если ему повезло прийти первым. Если же он пришёл, а ресурс уже кем-то заблокирован, то он сидит, ничего не делает, и ждёт освобождения.

![](pessimistic.svg)

Это самый простой и надёжный подход. Однако у него есть проблемы с производительностью. Либо из-за постоянных ожиданий, либо из-за холостых захватов, которые так-то весьма не бесплатны.

Кроме того, этот подход подвержен проблеме смертельного запирания или dead-lock. Это когда два участника успешно запирают два разных ресурса, а потом блокируются при попытке запереть ресурс уже запертый оппонентом. Получается, что при неосторожном обращении с запиранием, участники могут заблокировать друг дуга одновременно. И поэтому не смогут продолжить работу без вмешательства извне.

## Оптимистичная блокировка

Если конкуренция не слишком высока, оптимистичная блокировка может показать себя гораздо лучше. Тут участник сначала готовит новое состояние, а потом атомарно применяет его к источнику истины. Если повезёт. А если не повезёт, и кто-то успеет раньше него, то вся проделанная работа выкидывается, и начинается заново.

![](optimistic.svg)

Висеть в таком цикле участник может неограниченно долго. Формально при этом он не заблокирован и продолжает работу. Однако, фактически он работает вхолостую и не продвигается вперёд по выполняемой им задаче. Что логически эквивалентно блокировке.

Более того, один из вариантов реализации, например, мьютекса - это spin-lock, то есть кручение в бесконечном цикле в ожидании отпирания ресурса.

В распределённых системах так работают двухфазные коммиты. А в многопоточке для этого применяются lock-free алгоритмы.

Тут стоит обратить внимание на путаницу в терминах. lock-free алгоритмы раньше назывались неблокирующими, теперь считаются частным случаем неблокирующих. Но на самом деле это всё же механизм хоть и оптимистичной, но блокировки.

Преимуществами данного подхода является высокая производительность в условиях низкой конкуренции, и существенно более сложное достижение смертельного запирания. К недостаткам же можно отнести большой объём холостой работы при высокой конкуренции, и существенно более сложные алгоритмы, чувствительные к архитектурным особенностям.

## Терпеливость к разделению

Отличительной особенностью источника истины является возможность гарантировать консистентность.

Но согласие невозможно при разделении сети. Не можешь победить? Возглавь!

## Сходимость к согласию

Скорее всего вы слышали термин "Eventual Cоnsistency" или "Согласованность в конечном счёте". Так вот, оно на самом деле не про консистентность, а именно про конвергенцию. Wait-free алгоритмы межпоточного взаимодействия основаны на той же идее - отсутствие конкуренции за общий ресурс.

Однако, важно понимать, что консистентность тут уже в общем случае не может быть гарантирована. Так как слияние консистентных по отдельности изменений может выдавать уже неконсистентное состояние. Но с этим можно жить, если правильно организовывать данные и уметь нормализовывать неконсистентное состояние.

![](convergence.svg)

## Упорядоченная сходимость

> OT: Operational Transformation

![](order.svg)

## Полу-упорядоченная сходимость

> CmRDT: Conflict-free Commutative Replicated Data Type

![](semi-order.svg)

## Беспорядочная сходимость

> CvRDT: Conflict-free Convergent Replicated Data Type

![](unorder.svg)

## Согласны?

![](full.svg)

## Продолжение следует..

> ✅ Лайк
> ✅ Подписка
> ✅ Комментарий
> ✅ Поделись-ка

А на этом пока что всё. С вами был.. беспорядочный программер Дмитрий Карловский.