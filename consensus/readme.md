# Консистентно о Консенсусе

Здравствуйте, меня зовут Дмитрий Карловский. А вы на канале [Core Dump](https://www.youtube.com/channel/UC-qEImMrqSLZ9KLee1JTcuw), где мы берём разные темы из компьютерной науки и раскладываем их по полочкам.

И на этот раз мы постараемся прийти к согласию касательно согласованной классификации алгоритмов обеспечения консенсуса в системах со множеством участников. И попробуем выявить их фундаментальные особенности, проявляющиеся на разных масштабах: от ядер процессора, до серверных кластеров.

![](short.svg)

Вы можете [читать это как статью](https://github.com/nin-jin/slides/tree/master/consensus), либо [открыть в интерфейсе проведения презентаций](https://nin-jin.github.io/slides/consensus/).

## Consistency: Согласованность данных

Начнём с консистентности. Она же согласованность. Это - логическая непротиворечивость хранимых данных.

Например, если у Алисы родителем значится Боб, а у Боба родителем значится Алиса, то это явно какая-то лажа. Не могут они быть родителями друг друга одновременно. Данные не консистентны!

![](inconsistency.svg)

Согласованность часто путают с консенсусом. Особенно, когда данные частично хранятся на одном сервере, а частично на другом, но при этом должны быть друг с другом согласованы. Однако, консенсус немного о другом..

## Consensus: Согласие между участниками

Консенсус - это согласие группы участников касательно значения некоторого состояния. Например, если все считают Боба мужчиной, но сам он считает себя вертолётом, но согласия тут не наблюдается. Консенсус не достигнут!

![](discord.svg)

Важно понимать, что даже если у каждого участника состояние консистентно, между участницами при этом консенсуса может и не быть. И наоборот, участники могут достигнуть консенсуса, но получить при этом неконсистентное состояние.

## Достижение консенсуса

Все подходы по достижению консенсуса можно разделить на две большие группы..

![](consensus.svg)

Первая - это конкуренция за единый источник истины. Участники толпятся вокруг него, толкаются локтями, и пытаются внести в него свои изменения.

Транзакции в базах данных, атомарные операции в многопоточке, протоколы консенсуса в распределённых системах - это всё из этой оперы.

Отличительной особенностью такого подхода является возможность гарантировать консистентность.

Совершенно иной подход - конвергениция. Она же сходимость. Это кода участники независимо друг от друга меняют каждый своё состояние. И только своё. Но при этом они могут подглядывать к соседям и подливать их изменения к себе. А алгоритмы слияния изменений строятся так, чтобы состояния всех участников в конечном счёте сошлись к одному и тому же значению.

Скорее всего вы слышали термин "Eventual Cоnsistency" или "Согласованность в конечном счёте". Так вот, оно на самом деле не про консистентность, а именно про конвергенцию. Wait-free алгоритмы межпоточного взаимодействия основаны на той же идее - отсутствие конкуренции за общий ресурс.

Однако, важно понимать, что консистентность тут уже в общем случае не может быть гарантирована. Так как слияние консистентных по отдельности изменений может выдавать уже неконсистентное состояние. Но с этим можно жить, если правильно организовывать данные и уметь нормализовывать неконсистентное состояние.

## Concurrency: Конкуренция за источник истины

![](concurrency.svg)

## Пессимистичная блокировка

![](pessimistic.svg)

## Оптимистичная блокировка

![](optimistic.svg)

## Convergence: Сходимость к согласию

![](convergence.svg)

## Упорядоченная конвергенция

> OT: Operational Transformation

![](order.svg)

## Полу-упорядоченная конвергенция

> CmRDT: Conflict-free Commutative Replicated Data Type

![](semi-order.svg)

## Беспорядочная конвергенция

> CvRDT: Conflict-free Convergent Replicated Data Type

![](unorder.svg)

## Согласны?

![](full.svg)

## Продолжение следует..

> ✅ Лайк
> ✅ Подписка
> ✅ Комментарий
> ✅ Поделись-ка

А на этом пока что всё. С вами был беспорядочный программер Дмитрий Карловский.